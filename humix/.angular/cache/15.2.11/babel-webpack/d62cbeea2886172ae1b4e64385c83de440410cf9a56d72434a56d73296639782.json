{"ast":null,"code":"/**\r\n * @license Angular v15.2.10\r\n * (c) 2010-2022 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { isPlatformBrowser } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, NgZone, ApplicationRef, PLATFORM_ID, APP_INITIALIZER, Injector, NgModule } from '@angular/core';\nimport { defer, throwError, fromEvent, of, concat, Subject, NEVER, merge } from 'rxjs';\nimport { map, filter, switchMap, publish, take, tap, delay } from 'rxjs/operators';\nconst ERR_SW_NOT_SUPPORTED = 'Service workers are disabled or not supported by this browser';\nfunction errorObservable(message) {\n  return defer(() => throwError(new Error(message)));\n}\n/**\r\n * @publicApi\r\n */\nclass NgswCommChannel {\n  constructor(serviceWorker) {\n    this.serviceWorker = serviceWorker;\n    if (!serviceWorker) {\n      this.worker = this.events = this.registration = errorObservable(ERR_SW_NOT_SUPPORTED);\n    } else {\n      const controllerChangeEvents = fromEvent(serviceWorker, 'controllerchange');\n      const controllerChanges = controllerChangeEvents.pipe(map(() => serviceWorker.controller));\n      const currentController = defer(() => of(serviceWorker.controller));\n      const controllerWithChanges = concat(currentController, controllerChanges);\n      this.worker = controllerWithChanges.pipe(filter(c => !!c));\n      this.registration = this.worker.pipe(switchMap(() => serviceWorker.getRegistration()));\n      const rawEvents = fromEvent(serviceWorker, 'message');\n      const rawEventPayload = rawEvents.pipe(map(event => event.data));\n      const eventsUnconnected = rawEventPayload.pipe(filter(event => event && event.type));\n      const events = eventsUnconnected.pipe(publish());\n      events.connect();\n      this.events = events;\n    }\n  }\n  postMessage(action, payload) {\n    return this.worker.pipe(take(1), tap(sw => {\n      sw.postMessage({\n        action,\n        ...payload\n      });\n    })).toPromise().then(() => undefined);\n  }\n  postMessageWithOperation(type, payload, operationNonce) {\n    const waitForOperationCompleted = this.waitForOperationCompleted(operationNonce);\n    const postMessage = this.postMessage(type, payload);\n    return Promise.all([postMessage, waitForOperationCompleted]).then(([, result]) => result);\n  }\n  generateNonce() {\n    return Math.round(Math.random() * 10000000);\n  }\n  eventsOfType(type) {\n    let filterFn;\n    if (typeof type === 'string') {\n      filterFn = event => event.type === type;\n    } else {\n      filterFn = event => type.includes(event.type);\n    }\n    return this.events.pipe(filter(filterFn));\n  }\n  nextEventOfType(type) {\n    return this.eventsOfType(type).pipe(take(1));\n  }\n  waitForOperationCompleted(nonce) {\n    return this.eventsOfType('OPERATION_COMPLETED').pipe(filter(event => event.nonce === nonce), take(1), map(event => {\n      if (event.result !== undefined) {\n        return event.result;\n      }\n      throw new Error(event.error);\n    })).toPromise();\n  }\n  get isEnabled() {\n    return !!this.serviceWorker;\n  }\n}\n\n/**\r\n * Subscribe and listen to\r\n * [Web Push\r\n * Notifications](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices) through\r\n * Angular Service Worker.\r\n *\r\n * @usageNotes\r\n *\r\n * You can inject a `SwPush` instance into any component or service\r\n * as a dependency.\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"inject-sw-push\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * To subscribe, call `SwPush.requestSubscription()`, which asks the user for permission.\r\n * The call returns a `Promise` with a new\r\n * [`PushSubscription`](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)\r\n * instance.\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-push\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * A request is rejected if the user denies permission, or if the browser\r\n * blocks or does not support the Push API or ServiceWorkers.\r\n * Check `SwPush.isEnabled` to confirm status.\r\n *\r\n * Invoke Push Notifications by pushing a message with the following payload.\r\n *\r\n * ```ts\r\n * {\r\n *   \"notification\": {\r\n *     \"actions\": NotificationAction[],\r\n *     \"badge\": USVString,\r\n *     \"body\": DOMString,\r\n *     \"data\": any,\r\n *     \"dir\": \"auto\"|\"ltr\"|\"rtl\",\r\n *     \"icon\": USVString,\r\n *     \"image\": USVString,\r\n *     \"lang\": DOMString,\r\n *     \"renotify\": boolean,\r\n *     \"requireInteraction\": boolean,\r\n *     \"silent\": boolean,\r\n *     \"tag\": DOMString,\r\n *     \"timestamp\": DOMTimeStamp,\r\n *     \"title\": DOMString,\r\n *     \"vibrate\": number[]\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Only `title` is required. See `Notification`\r\n * [instance\r\n * properties](https://developer.mozilla.org/en-US/docs/Web/API/Notification#Instance_properties).\r\n *\r\n * While the subscription is active, Service Worker listens for\r\n * [PushEvent](https://developer.mozilla.org/en-US/docs/Web/API/PushEvent)\r\n * occurrences and creates\r\n * [Notification](https://developer.mozilla.org/en-US/docs/Web/API/Notification)\r\n * instances in response.\r\n *\r\n * Unsubscribe using `SwPush.unsubscribe()`.\r\n *\r\n * An application can subscribe to `SwPush.notificationClicks` observable to be notified when a user\r\n * clicks on a notification. For example:\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-notification-clicks\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * You can read more on handling notification clicks in the [Service worker notifications\r\n * guide](guide/service-worker-notifications).\r\n *\r\n * @see [Push Notifications](https://developers.google.com/web/fundamentals/codelabs/push-notifications/)\r\n * @see [Angular Push Notifications](https://blog.angular-university.io/angular-push-notifications/)\r\n * @see [MDN: Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API)\r\n * @see [MDN: Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API)\r\n * @see [MDN: Web Push API Notifications best practices](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices)\r\n *\r\n * @publicApi\r\n */\nclass SwPush {\n  /**\r\n   * True if the Service Worker is enabled (supported by the browser and enabled via\r\n   * `ServiceWorkerModule`).\r\n   */\n  get isEnabled() {\n    return this.sw.isEnabled;\n  }\n  constructor(sw) {\n    this.sw = sw;\n    this.pushManager = null;\n    this.subscriptionChanges = new Subject();\n    if (!sw.isEnabled) {\n      this.messages = NEVER;\n      this.notificationClicks = NEVER;\n      this.subscription = NEVER;\n      return;\n    }\n    this.messages = this.sw.eventsOfType('PUSH').pipe(map(message => message.data));\n    this.notificationClicks = this.sw.eventsOfType('NOTIFICATION_CLICK').pipe(map(message => message.data));\n    this.pushManager = this.sw.registration.pipe(map(registration => registration.pushManager));\n    const workerDrivenSubscriptions = this.pushManager.pipe(switchMap(pm => pm.getSubscription()));\n    this.subscription = merge(workerDrivenSubscriptions, this.subscriptionChanges);\n  }\n  /**\r\n   * Subscribes to Web Push Notifications,\r\n   * after requesting and receiving user permission.\r\n   *\r\n   * @param options An object containing the `serverPublicKey` string.\r\n   * @returns A Promise that resolves to the new subscription object.\r\n   */\n  requestSubscription(options) {\n    if (!this.sw.isEnabled || this.pushManager === null) {\n      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n    }\n    const pushOptions = {\n      userVisibleOnly: true\n    };\n    let key = this.decodeBase64(options.serverPublicKey.replace(/_/g, '/').replace(/-/g, '+'));\n    let applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));\n    for (let i = 0; i < key.length; i++) {\n      applicationServerKey[i] = key.charCodeAt(i);\n    }\n    pushOptions.applicationServerKey = applicationServerKey;\n    return this.pushManager.pipe(switchMap(pm => pm.subscribe(pushOptions)), take(1)).toPromise().then(sub => {\n      this.subscriptionChanges.next(sub);\n      return sub;\n    });\n  }\n  /**\r\n   * Unsubscribes from Service Worker push notifications.\r\n   *\r\n   * @returns A Promise that is resolved when the operation succeeds, or is rejected if there is no\r\n   *          active subscription or the unsubscribe operation fails.\r\n   */\n  unsubscribe() {\n    if (!this.sw.isEnabled) {\n      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n    }\n    const doUnsubscribe = sub => {\n      if (sub === null) {\n        throw new Error('Not subscribed to push notifications.');\n      }\n      return sub.unsubscribe().then(success => {\n        if (!success) {\n          throw new Error('Unsubscribe failed!');\n        }\n        this.subscriptionChanges.next(null);\n      });\n    };\n    return this.subscription.pipe(take(1), switchMap(doUnsubscribe)).toPromise();\n  }\n  decodeBase64(input) {\n    return atob(input);\n  }\n}\nSwPush.ɵfac = function SwPush_Factory(t) {\n  return new (t || SwPush)(i0.ɵɵinject(NgswCommChannel));\n};\nSwPush.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SwPush,\n  factory: SwPush.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwPush, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: NgswCommChannel\n    }];\n  }, null);\n})();\n\n/**\r\n * Subscribe to update notifications from the Service Worker, trigger update\r\n * checks, and forcibly activate updates.\r\n *\r\n * @see {@link guide/service-worker-communications Service worker communication guide}\r\n *\r\n * @publicApi\r\n */\nclass SwUpdate {\n  /**\r\n   * True if the Service Worker is enabled (supported by the browser and enabled via\r\n   * `ServiceWorkerModule`).\r\n   */\n  get isEnabled() {\n    return this.sw.isEnabled;\n  }\n  constructor(sw) {\n    this.sw = sw;\n    if (!sw.isEnabled) {\n      this.versionUpdates = NEVER;\n      this.available = NEVER;\n      this.activated = NEVER;\n      this.unrecoverable = NEVER;\n      return;\n    }\n    this.versionUpdates = this.sw.eventsOfType(['VERSION_DETECTED', 'VERSION_INSTALLATION_FAILED', 'VERSION_READY', 'NO_NEW_VERSION_DETECTED']);\n    this.available = this.versionUpdates.pipe(filter(evt => evt.type === 'VERSION_READY'), map(evt => ({\n      type: 'UPDATE_AVAILABLE',\n      current: evt.currentVersion,\n      available: evt.latestVersion\n    })));\n    this.activated = this.sw.eventsOfType('UPDATE_ACTIVATED');\n    this.unrecoverable = this.sw.eventsOfType('UNRECOVERABLE_STATE');\n  }\n  /**\r\n   * Checks for an update and waits until the new version is downloaded from the server and ready\r\n   * for activation.\r\n   *\r\n   * @returns a promise that\r\n   * - resolves to `true` if a new version was found and is ready to be activated.\r\n   * - resolves to `false` if no new version was found\r\n   * - rejects if any error occurs\r\n   */\n  checkForUpdate() {\n    if (!this.sw.isEnabled) {\n      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n    }\n    const nonce = this.sw.generateNonce();\n    return this.sw.postMessageWithOperation('CHECK_FOR_UPDATES', {\n      nonce\n    }, nonce);\n  }\n  /**\r\n   * Updates the current client (i.e. browser tab) to the latest version that is ready for\r\n   * activation.\r\n   *\r\n   * In most cases, you should not use this method and instead should update a client by reloading\r\n   * the page.\r\n   *\r\n   * <div class=\"alert is-important\">\r\n   *\r\n   * Updating a client without reloading can easily result in a broken application due to a version\r\n   * mismatch between the [application shell](guide/glossary#app-shell) and other page resources,\r\n   * such as [lazy-loaded chunks](guide/glossary#lazy-loading), whose filenames may change between\r\n   * versions.\r\n   *\r\n   * Only use this method, if you are certain it is safe for your specific use case.\r\n   *\r\n   * </div>\r\n   *\r\n   * @returns a promise that\r\n   *  - resolves to `true` if an update was activated successfully\r\n   *  - resolves to `false` if no update was available (for example, the client was already on the\r\n   *    latest version).\r\n   *  - rejects if any error occurs\r\n   */\n  activateUpdate() {\n    if (!this.sw.isEnabled) {\n      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n    }\n    const nonce = this.sw.generateNonce();\n    return this.sw.postMessageWithOperation('ACTIVATE_UPDATE', {\n      nonce\n    }, nonce);\n  }\n}\nSwUpdate.ɵfac = function SwUpdate_Factory(t) {\n  return new (t || SwUpdate)(i0.ɵɵinject(NgswCommChannel));\n};\nSwUpdate.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SwUpdate,\n  factory: SwUpdate.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwUpdate, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: NgswCommChannel\n    }];\n  }, null);\n})();\n\n/**\r\n * Token that can be used to provide options for `ServiceWorkerModule` outside of\r\n * `ServiceWorkerModule.register()`.\r\n *\r\n * You can use this token to define a provider that generates the registration options at runtime,\r\n * for example via a function call:\r\n *\r\n * {@example service-worker/registration-options/module.ts region=\"registration-options\"\r\n *     header=\"app.module.ts\"}\r\n *\r\n * @publicApi\r\n */\nclass SwRegistrationOptions {}\nconst SCRIPT = new InjectionToken('NGSW_REGISTER_SCRIPT');\nfunction ngswAppInitializer(injector, script, options, platformId) {\n  return () => {\n    if (!(isPlatformBrowser(platformId) && 'serviceWorker' in navigator && options.enabled !== false)) {\n      return;\n    }\n    // Wait for service worker controller changes, and fire an INITIALIZE action when a new SW\n    // becomes active. This allows the SW to initialize itself even if there is no application\n    // traffic.\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      if (navigator.serviceWorker.controller !== null) {\n        navigator.serviceWorker.controller.postMessage({\n          action: 'INITIALIZE'\n        });\n      }\n    });\n    let readyToRegister$;\n    if (typeof options.registrationStrategy === 'function') {\n      readyToRegister$ = options.registrationStrategy();\n    } else {\n      const [strategy, ...args] = (options.registrationStrategy || 'registerWhenStable:30000').split(':');\n      switch (strategy) {\n        case 'registerImmediately':\n          readyToRegister$ = of(null);\n          break;\n        case 'registerWithDelay':\n          readyToRegister$ = delayWithTimeout(+args[0] || 0);\n          break;\n        case 'registerWhenStable':\n          readyToRegister$ = !args[0] ? whenStable(injector) : merge(whenStable(injector), delayWithTimeout(+args[0]));\n          break;\n        default:\n          // Unknown strategy.\n          throw new Error(`Unknown ServiceWorker registration strategy: ${options.registrationStrategy}`);\n      }\n    }\n    // Don't return anything to avoid blocking the application until the SW is registered.\n    // Also, run outside the Angular zone to avoid preventing the app from stabilizing (especially\n    // given that some registration strategies wait for the app to stabilize).\n    // Catch and log the error if SW registration fails to avoid uncaught rejection warning.\n    const ngZone = injector.get(NgZone);\n    ngZone.runOutsideAngular(() => readyToRegister$.pipe(take(1)).subscribe(() => navigator.serviceWorker.register(script, {\n      scope: options.scope\n    }).catch(err => console.error('Service worker registration failed with:', err))));\n  };\n}\nfunction delayWithTimeout(timeout) {\n  return of(null).pipe(delay(timeout));\n}\nfunction whenStable(injector) {\n  const appRef = injector.get(ApplicationRef);\n  return appRef.isStable.pipe(filter(stable => stable));\n}\nfunction ngswCommChannelFactory(opts, platformId) {\n  return new NgswCommChannel(isPlatformBrowser(platformId) && opts.enabled !== false ? navigator.serviceWorker : undefined);\n}\n/**\r\n * @publicApi\r\n */\nclass ServiceWorkerModule {\n  /**\r\n   * Register the given Angular Service Worker script.\r\n   *\r\n   * If `enabled` is set to `false` in the given options, the module will behave as if service\r\n   * workers are not supported by the browser, and the service worker will not be registered.\r\n   */\n  static register(script, opts = {}) {\n    return {\n      ngModule: ServiceWorkerModule,\n      providers: [{\n        provide: SCRIPT,\n        useValue: script\n      }, {\n        provide: SwRegistrationOptions,\n        useValue: opts\n      }, {\n        provide: NgswCommChannel,\n        useFactory: ngswCommChannelFactory,\n        deps: [SwRegistrationOptions, PLATFORM_ID]\n      }, {\n        provide: APP_INITIALIZER,\n        useFactory: ngswAppInitializer,\n        deps: [Injector, SCRIPT, SwRegistrationOptions, PLATFORM_ID],\n        multi: true\n      }]\n    };\n  }\n}\nServiceWorkerModule.ɵfac = function ServiceWorkerModule_Factory(t) {\n  return new (t || ServiceWorkerModule)();\n};\nServiceWorkerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ServiceWorkerModule\n});\nServiceWorkerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [SwPush, SwUpdate]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ServiceWorkerModule, [{\n    type: NgModule,\n    args: [{\n      providers: [SwPush, SwUpdate]\n    }]\n  }], null, null);\n})();\n\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of this package.\r\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { ServiceWorkerModule, SwPush, SwRegistrationOptions, SwUpdate };","map":{"version":3,"names":["isPlatformBrowser","i0","Injectable","InjectionToken","NgZone","ApplicationRef","PLATFORM_ID","APP_INITIALIZER","Injector","NgModule","defer","throwError","fromEvent","of","concat","Subject","NEVER","merge","map","filter","switchMap","publish","take","tap","delay","ERR_SW_NOT_SUPPORTED","errorObservable","message","Error","NgswCommChannel","constructor","serviceWorker","worker","events","registration","controllerChangeEvents","controllerChanges","pipe","controller","currentController","controllerWithChanges","c","getRegistration","rawEvents","rawEventPayload","event","data","eventsUnconnected","type","connect","postMessage","action","payload","sw","toPromise","then","undefined","postMessageWithOperation","operationNonce","waitForOperationCompleted","Promise","all","result","generateNonce","Math","round","random","eventsOfType","filterFn","includes","nextEventOfType","nonce","error","isEnabled","SwPush","pushManager","subscriptionChanges","messages","notificationClicks","subscription","workerDrivenSubscriptions","pm","getSubscription","requestSubscription","options","reject","pushOptions","userVisibleOnly","key","decodeBase64","serverPublicKey","replace","applicationServerKey","Uint8Array","ArrayBuffer","length","i","charCodeAt","subscribe","sub","next","unsubscribe","doUnsubscribe","success","input","atob","ɵfac","ɵprov","SwUpdate","versionUpdates","available","activated","unrecoverable","evt","current","currentVersion","latestVersion","checkForUpdate","activateUpdate","SwRegistrationOptions","SCRIPT","ngswAppInitializer","injector","script","platformId","navigator","enabled","addEventListener","readyToRegister$","registrationStrategy","strategy","args","split","delayWithTimeout","whenStable","ngZone","get","runOutsideAngular","register","scope","catch","err","console","timeout","appRef","isStable","stable","ngswCommChannelFactory","opts","ServiceWorkerModule","ngModule","providers","provide","useValue","useFactory","deps","multi","ɵmod","ɵinj"],"sources":["C:/Users/gatit/OneDrive/Escritorio/proyectoHumedad/grupo5B_PII/humix/node_modules/@angular/service-worker/fesm2020/service-worker.mjs"],"sourcesContent":["/**\r\n * @license Angular v15.2.10\r\n * (c) 2010-2022 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { isPlatformBrowser } from '@angular/common';\r\nimport * as i0 from '@angular/core';\r\nimport { Injectable, InjectionToken, NgZone, ApplicationRef, PLATFORM_ID, APP_INITIALIZER, Injector, NgModule } from '@angular/core';\r\nimport { defer, throwError, fromEvent, of, concat, Subject, NEVER, merge } from 'rxjs';\r\nimport { map, filter, switchMap, publish, take, tap, delay } from 'rxjs/operators';\r\n\r\nconst ERR_SW_NOT_SUPPORTED = 'Service workers are disabled or not supported by this browser';\r\nfunction errorObservable(message) {\r\n    return defer(() => throwError(new Error(message)));\r\n}\r\n/**\r\n * @publicApi\r\n */\r\nclass NgswCommChannel {\r\n    constructor(serviceWorker) {\r\n        this.serviceWorker = serviceWorker;\r\n        if (!serviceWorker) {\r\n            this.worker = this.events = this.registration = errorObservable(ERR_SW_NOT_SUPPORTED);\r\n        }\r\n        else {\r\n            const controllerChangeEvents = fromEvent(serviceWorker, 'controllerchange');\r\n            const controllerChanges = controllerChangeEvents.pipe(map(() => serviceWorker.controller));\r\n            const currentController = defer(() => of(serviceWorker.controller));\r\n            const controllerWithChanges = concat(currentController, controllerChanges);\r\n            this.worker = controllerWithChanges.pipe(filter((c) => !!c));\r\n            this.registration = (this.worker.pipe(switchMap(() => serviceWorker.getRegistration())));\r\n            const rawEvents = fromEvent(serviceWorker, 'message');\r\n            const rawEventPayload = rawEvents.pipe(map(event => event.data));\r\n            const eventsUnconnected = rawEventPayload.pipe(filter(event => event && event.type));\r\n            const events = eventsUnconnected.pipe(publish());\r\n            events.connect();\r\n            this.events = events;\r\n        }\r\n    }\r\n    postMessage(action, payload) {\r\n        return this.worker\r\n            .pipe(take(1), tap((sw) => {\r\n            sw.postMessage({\r\n                action,\r\n                ...payload,\r\n            });\r\n        }))\r\n            .toPromise()\r\n            .then(() => undefined);\r\n    }\r\n    postMessageWithOperation(type, payload, operationNonce) {\r\n        const waitForOperationCompleted = this.waitForOperationCompleted(operationNonce);\r\n        const postMessage = this.postMessage(type, payload);\r\n        return Promise.all([postMessage, waitForOperationCompleted]).then(([, result]) => result);\r\n    }\r\n    generateNonce() {\r\n        return Math.round(Math.random() * 10000000);\r\n    }\r\n    eventsOfType(type) {\r\n        let filterFn;\r\n        if (typeof type === 'string') {\r\n            filterFn = (event) => event.type === type;\r\n        }\r\n        else {\r\n            filterFn = (event) => type.includes(event.type);\r\n        }\r\n        return this.events.pipe(filter(filterFn));\r\n    }\r\n    nextEventOfType(type) {\r\n        return this.eventsOfType(type).pipe(take(1));\r\n    }\r\n    waitForOperationCompleted(nonce) {\r\n        return this.eventsOfType('OPERATION_COMPLETED')\r\n            .pipe(filter(event => event.nonce === nonce), take(1), map(event => {\r\n            if (event.result !== undefined) {\r\n                return event.result;\r\n            }\r\n            throw new Error(event.error);\r\n        }))\r\n            .toPromise();\r\n    }\r\n    get isEnabled() {\r\n        return !!this.serviceWorker;\r\n    }\r\n}\r\n\r\n/**\r\n * Subscribe and listen to\r\n * [Web Push\r\n * Notifications](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices) through\r\n * Angular Service Worker.\r\n *\r\n * @usageNotes\r\n *\r\n * You can inject a `SwPush` instance into any component or service\r\n * as a dependency.\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"inject-sw-push\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * To subscribe, call `SwPush.requestSubscription()`, which asks the user for permission.\r\n * The call returns a `Promise` with a new\r\n * [`PushSubscription`](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)\r\n * instance.\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-push\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * A request is rejected if the user denies permission, or if the browser\r\n * blocks or does not support the Push API or ServiceWorkers.\r\n * Check `SwPush.isEnabled` to confirm status.\r\n *\r\n * Invoke Push Notifications by pushing a message with the following payload.\r\n *\r\n * ```ts\r\n * {\r\n *   \"notification\": {\r\n *     \"actions\": NotificationAction[],\r\n *     \"badge\": USVString,\r\n *     \"body\": DOMString,\r\n *     \"data\": any,\r\n *     \"dir\": \"auto\"|\"ltr\"|\"rtl\",\r\n *     \"icon\": USVString,\r\n *     \"image\": USVString,\r\n *     \"lang\": DOMString,\r\n *     \"renotify\": boolean,\r\n *     \"requireInteraction\": boolean,\r\n *     \"silent\": boolean,\r\n *     \"tag\": DOMString,\r\n *     \"timestamp\": DOMTimeStamp,\r\n *     \"title\": DOMString,\r\n *     \"vibrate\": number[]\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Only `title` is required. See `Notification`\r\n * [instance\r\n * properties](https://developer.mozilla.org/en-US/docs/Web/API/Notification#Instance_properties).\r\n *\r\n * While the subscription is active, Service Worker listens for\r\n * [PushEvent](https://developer.mozilla.org/en-US/docs/Web/API/PushEvent)\r\n * occurrences and creates\r\n * [Notification](https://developer.mozilla.org/en-US/docs/Web/API/Notification)\r\n * instances in response.\r\n *\r\n * Unsubscribe using `SwPush.unsubscribe()`.\r\n *\r\n * An application can subscribe to `SwPush.notificationClicks` observable to be notified when a user\r\n * clicks on a notification. For example:\r\n *\r\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-notification-clicks\"\r\n * header=\"app.component.ts\"></code-example>\r\n *\r\n * You can read more on handling notification clicks in the [Service worker notifications\r\n * guide](guide/service-worker-notifications).\r\n *\r\n * @see [Push Notifications](https://developers.google.com/web/fundamentals/codelabs/push-notifications/)\r\n * @see [Angular Push Notifications](https://blog.angular-university.io/angular-push-notifications/)\r\n * @see [MDN: Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API)\r\n * @see [MDN: Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API)\r\n * @see [MDN: Web Push API Notifications best practices](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices)\r\n *\r\n * @publicApi\r\n */\r\nclass SwPush {\r\n    /**\r\n     * True if the Service Worker is enabled (supported by the browser and enabled via\r\n     * `ServiceWorkerModule`).\r\n     */\r\n    get isEnabled() {\r\n        return this.sw.isEnabled;\r\n    }\r\n    constructor(sw) {\r\n        this.sw = sw;\r\n        this.pushManager = null;\r\n        this.subscriptionChanges = new Subject();\r\n        if (!sw.isEnabled) {\r\n            this.messages = NEVER;\r\n            this.notificationClicks = NEVER;\r\n            this.subscription = NEVER;\r\n            return;\r\n        }\r\n        this.messages = this.sw.eventsOfType('PUSH').pipe(map(message => message.data));\r\n        this.notificationClicks =\r\n            this.sw.eventsOfType('NOTIFICATION_CLICK').pipe(map((message) => message.data));\r\n        this.pushManager = this.sw.registration.pipe(map(registration => registration.pushManager));\r\n        const workerDrivenSubscriptions = this.pushManager.pipe(switchMap(pm => pm.getSubscription()));\r\n        this.subscription = merge(workerDrivenSubscriptions, this.subscriptionChanges);\r\n    }\r\n    /**\r\n     * Subscribes to Web Push Notifications,\r\n     * after requesting and receiving user permission.\r\n     *\r\n     * @param options An object containing the `serverPublicKey` string.\r\n     * @returns A Promise that resolves to the new subscription object.\r\n     */\r\n    requestSubscription(options) {\r\n        if (!this.sw.isEnabled || this.pushManager === null) {\r\n            return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\r\n        }\r\n        const pushOptions = { userVisibleOnly: true };\r\n        let key = this.decodeBase64(options.serverPublicKey.replace(/_/g, '/').replace(/-/g, '+'));\r\n        let applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));\r\n        for (let i = 0; i < key.length; i++) {\r\n            applicationServerKey[i] = key.charCodeAt(i);\r\n        }\r\n        pushOptions.applicationServerKey = applicationServerKey;\r\n        return this.pushManager.pipe(switchMap(pm => pm.subscribe(pushOptions)), take(1))\r\n            .toPromise()\r\n            .then(sub => {\r\n            this.subscriptionChanges.next(sub);\r\n            return sub;\r\n        });\r\n    }\r\n    /**\r\n     * Unsubscribes from Service Worker push notifications.\r\n     *\r\n     * @returns A Promise that is resolved when the operation succeeds, or is rejected if there is no\r\n     *          active subscription or the unsubscribe operation fails.\r\n     */\r\n    unsubscribe() {\r\n        if (!this.sw.isEnabled) {\r\n            return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\r\n        }\r\n        const doUnsubscribe = (sub) => {\r\n            if (sub === null) {\r\n                throw new Error('Not subscribed to push notifications.');\r\n            }\r\n            return sub.unsubscribe().then(success => {\r\n                if (!success) {\r\n                    throw new Error('Unsubscribe failed!');\r\n                }\r\n                this.subscriptionChanges.next(null);\r\n            });\r\n        };\r\n        return this.subscription.pipe(take(1), switchMap(doUnsubscribe)).toPromise();\r\n    }\r\n    decodeBase64(input) {\r\n        return atob(input);\r\n    }\r\n}\r\nSwPush.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: SwPush, deps: [{ token: NgswCommChannel }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSwPush.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: SwPush });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: SwPush, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: NgswCommChannel }]; } });\r\n\r\n/**\r\n * Subscribe to update notifications from the Service Worker, trigger update\r\n * checks, and forcibly activate updates.\r\n *\r\n * @see {@link guide/service-worker-communications Service worker communication guide}\r\n *\r\n * @publicApi\r\n */\r\nclass SwUpdate {\r\n    /**\r\n     * True if the Service Worker is enabled (supported by the browser and enabled via\r\n     * `ServiceWorkerModule`).\r\n     */\r\n    get isEnabled() {\r\n        return this.sw.isEnabled;\r\n    }\r\n    constructor(sw) {\r\n        this.sw = sw;\r\n        if (!sw.isEnabled) {\r\n            this.versionUpdates = NEVER;\r\n            this.available = NEVER;\r\n            this.activated = NEVER;\r\n            this.unrecoverable = NEVER;\r\n            return;\r\n        }\r\n        this.versionUpdates = this.sw.eventsOfType([\r\n            'VERSION_DETECTED',\r\n            'VERSION_INSTALLATION_FAILED',\r\n            'VERSION_READY',\r\n            'NO_NEW_VERSION_DETECTED',\r\n        ]);\r\n        this.available = this.versionUpdates.pipe(filter((evt) => evt.type === 'VERSION_READY'), map(evt => ({\r\n            type: 'UPDATE_AVAILABLE',\r\n            current: evt.currentVersion,\r\n            available: evt.latestVersion,\r\n        })));\r\n        this.activated = this.sw.eventsOfType('UPDATE_ACTIVATED');\r\n        this.unrecoverable = this.sw.eventsOfType('UNRECOVERABLE_STATE');\r\n    }\r\n    /**\r\n     * Checks for an update and waits until the new version is downloaded from the server and ready\r\n     * for activation.\r\n     *\r\n     * @returns a promise that\r\n     * - resolves to `true` if a new version was found and is ready to be activated.\r\n     * - resolves to `false` if no new version was found\r\n     * - rejects if any error occurs\r\n     */\r\n    checkForUpdate() {\r\n        if (!this.sw.isEnabled) {\r\n            return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\r\n        }\r\n        const nonce = this.sw.generateNonce();\r\n        return this.sw.postMessageWithOperation('CHECK_FOR_UPDATES', { nonce }, nonce);\r\n    }\r\n    /**\r\n     * Updates the current client (i.e. browser tab) to the latest version that is ready for\r\n     * activation.\r\n     *\r\n     * In most cases, you should not use this method and instead should update a client by reloading\r\n     * the page.\r\n     *\r\n     * <div class=\"alert is-important\">\r\n     *\r\n     * Updating a client without reloading can easily result in a broken application due to a version\r\n     * mismatch between the [application shell](guide/glossary#app-shell) and other page resources,\r\n     * such as [lazy-loaded chunks](guide/glossary#lazy-loading), whose filenames may change between\r\n     * versions.\r\n     *\r\n     * Only use this method, if you are certain it is safe for your specific use case.\r\n     *\r\n     * </div>\r\n     *\r\n     * @returns a promise that\r\n     *  - resolves to `true` if an update was activated successfully\r\n     *  - resolves to `false` if no update was available (for example, the client was already on the\r\n     *    latest version).\r\n     *  - rejects if any error occurs\r\n     */\r\n    activateUpdate() {\r\n        if (!this.sw.isEnabled) {\r\n            return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\r\n        }\r\n        const nonce = this.sw.generateNonce();\r\n        return this.sw.postMessageWithOperation('ACTIVATE_UPDATE', { nonce }, nonce);\r\n    }\r\n}\r\nSwUpdate.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: SwUpdate, deps: [{ token: NgswCommChannel }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSwUpdate.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: SwUpdate });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: SwUpdate, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: NgswCommChannel }]; } });\r\n\r\n/**\r\n * Token that can be used to provide options for `ServiceWorkerModule` outside of\r\n * `ServiceWorkerModule.register()`.\r\n *\r\n * You can use this token to define a provider that generates the registration options at runtime,\r\n * for example via a function call:\r\n *\r\n * {@example service-worker/registration-options/module.ts region=\"registration-options\"\r\n *     header=\"app.module.ts\"}\r\n *\r\n * @publicApi\r\n */\r\nclass SwRegistrationOptions {\r\n}\r\nconst SCRIPT = new InjectionToken('NGSW_REGISTER_SCRIPT');\r\nfunction ngswAppInitializer(injector, script, options, platformId) {\r\n    return () => {\r\n        if (!(isPlatformBrowser(platformId) && ('serviceWorker' in navigator) &&\r\n            options.enabled !== false)) {\r\n            return;\r\n        }\r\n        // Wait for service worker controller changes, and fire an INITIALIZE action when a new SW\r\n        // becomes active. This allows the SW to initialize itself even if there is no application\r\n        // traffic.\r\n        navigator.serviceWorker.addEventListener('controllerchange', () => {\r\n            if (navigator.serviceWorker.controller !== null) {\r\n                navigator.serviceWorker.controller.postMessage({ action: 'INITIALIZE' });\r\n            }\r\n        });\r\n        let readyToRegister$;\r\n        if (typeof options.registrationStrategy === 'function') {\r\n            readyToRegister$ = options.registrationStrategy();\r\n        }\r\n        else {\r\n            const [strategy, ...args] = (options.registrationStrategy || 'registerWhenStable:30000').split(':');\r\n            switch (strategy) {\r\n                case 'registerImmediately':\r\n                    readyToRegister$ = of(null);\r\n                    break;\r\n                case 'registerWithDelay':\r\n                    readyToRegister$ = delayWithTimeout(+args[0] || 0);\r\n                    break;\r\n                case 'registerWhenStable':\r\n                    readyToRegister$ = !args[0] ? whenStable(injector) :\r\n                        merge(whenStable(injector), delayWithTimeout(+args[0]));\r\n                    break;\r\n                default:\r\n                    // Unknown strategy.\r\n                    throw new Error(`Unknown ServiceWorker registration strategy: ${options.registrationStrategy}`);\r\n            }\r\n        }\r\n        // Don't return anything to avoid blocking the application until the SW is registered.\r\n        // Also, run outside the Angular zone to avoid preventing the app from stabilizing (especially\r\n        // given that some registration strategies wait for the app to stabilize).\r\n        // Catch and log the error if SW registration fails to avoid uncaught rejection warning.\r\n        const ngZone = injector.get(NgZone);\r\n        ngZone.runOutsideAngular(() => readyToRegister$.pipe(take(1)).subscribe(() => navigator.serviceWorker.register(script, { scope: options.scope })\r\n            .catch(err => console.error('Service worker registration failed with:', err))));\r\n    };\r\n}\r\nfunction delayWithTimeout(timeout) {\r\n    return of(null).pipe(delay(timeout));\r\n}\r\nfunction whenStable(injector) {\r\n    const appRef = injector.get(ApplicationRef);\r\n    return appRef.isStable.pipe(filter(stable => stable));\r\n}\r\nfunction ngswCommChannelFactory(opts, platformId) {\r\n    return new NgswCommChannel(isPlatformBrowser(platformId) && opts.enabled !== false ? navigator.serviceWorker :\r\n        undefined);\r\n}\r\n/**\r\n * @publicApi\r\n */\r\nclass ServiceWorkerModule {\r\n    /**\r\n     * Register the given Angular Service Worker script.\r\n     *\r\n     * If `enabled` is set to `false` in the given options, the module will behave as if service\r\n     * workers are not supported by the browser, and the service worker will not be registered.\r\n     */\r\n    static register(script, opts = {}) {\r\n        return {\r\n            ngModule: ServiceWorkerModule,\r\n            providers: [\r\n                { provide: SCRIPT, useValue: script },\r\n                { provide: SwRegistrationOptions, useValue: opts },\r\n                {\r\n                    provide: NgswCommChannel,\r\n                    useFactory: ngswCommChannelFactory,\r\n                    deps: [SwRegistrationOptions, PLATFORM_ID]\r\n                },\r\n                {\r\n                    provide: APP_INITIALIZER,\r\n                    useFactory: ngswAppInitializer,\r\n                    deps: [Injector, SCRIPT, SwRegistrationOptions, PLATFORM_ID],\r\n                    multi: true,\r\n                },\r\n            ],\r\n        };\r\n    }\r\n}\r\nServiceWorkerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: ServiceWorkerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nServiceWorkerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.2.10\", ngImport: i0, type: ServiceWorkerModule });\r\nServiceWorkerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: ServiceWorkerModule, providers: [SwPush, SwUpdate] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.10\", ngImport: i0, type: ServiceWorkerModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    providers: [SwPush, SwUpdate],\r\n                }]\r\n        }] });\r\n\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of this package.\r\n */\r\n// This file only reexports content of the `src` folder. Keep it that way.\r\n\r\n// This file is not used to build this module. It is only used during editing\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { ServiceWorkerModule, SwPush, SwRegistrationOptions, SwUpdate };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}